<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>wfc: Титульная страница</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">wfc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Поиск');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">wfc Документация</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>Документация <a href="https://mambaru.github.io/wfc_io/index.html">doxygen</a>.</li>
<li>Репозитарий на <a href="https://github.com/mambaru/wfc_io">github.com</a>.</li>
<li>Отчет <a href="https://mambaru.github.io/wfc_io/cov-report/index.html">coverage</a></li>
</ul>
<h1>wfc_io: Пакет сетевых модулей</h1>
<p class="">Включает модули:</p><ul>
<li>server-tcp</li>
<li>server-udp</li>
<li>client-tcp</li>
<li>io-queue -</li>
<li>statistics - сбор статистики</li>
</ul>
<h2>server-tcp</h2>
<p class="">Минимальная конфигурация: </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;server-tcp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-tcp1&quot;,</div><div class="line">      &quot;port&quot;: &quot;12345&quot;</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p> В этой конфигурации сервер открывает порт на localhost, акцептит подключения, но сбрасывает их при попытке отправить ему данные. Для полноценной работы необходимо указать цель, которая будет обрабатывать входящий поток данных. Это, как правило, jsonrpc-сервис прикладного модуля или вспомогательные io- и jsonrpc-модули. В следующем примере входящие сообщения отправляются в сыром виде hash-объекту из <a href="https://github.com/mambaru/demod">демо</a> примера: </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;server-tcp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-tcp1&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash1&quot;,</div><div class="line">      &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">      &quot;port&quot;: &quot;12345&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash1&quot;</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p> <b>server-tcp</b> поддерживает динамическую реконфигурацию, но при реконфигурировании все текущие соединения сбрасываются. В suspend-режиме работает как эхо-сервис. Если включена динамическая реконфигурация и изменен только флаг suspend, то изменения вступают в силу только для новых подключений, а текущие продолжают работать.</p>
<p class="">По умолчанию архитектура однопоточная (thrеads=0, работает в основном потоке приложения), при увеличении числа потоков работает в режиме акцептор-на-поток, соединение работает в том же потоке, где и получило акцепт. При высоких нагрузках рекомендуется выделить хотя-бы один поток (thrеads=1) в этом режиме сервер так же однопоточный, но работает в отдельном потоке, и не захламляет заданиями основную очередь приложения, где крутятся таймеры и пр. Если используются очереди, то выделять большое количество потоков для сервера не имеет смысла, лучше увеличить число потоков для разбора очередей (см. <a href="https://github.com/mambaru/wfc_core">workflow</a>).</p>
<p class="">Если время ответа прикладной логики стабильно невысокое и клиент работает в режиме подключение на запрос, то использование очередей может не дать профита, а только увеличит нагрузку на CPU. Для постоянных подключений лучше использовать очередь. Если профиль нагрузки смешанный, то можно сделать два объекта сервера на разных портах, и по разному сконфигурировать последовательность обработки.</p>
<p class="">Конфигурация: </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;server-tcp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-tcp1&quot;,</div><div class="line">      /* В отключенном режиме сервер не создается*/</div><div class="line">      &quot;enabled&quot;: true,</div><div class="line">      /* В режиме suspend работает как эхо-сервер */</div><div class="line">      &quot;suspend&quot;: false,</div><div class="line">      /* Приоритет запуска. Укажите минимальный (максимальное значение), если порты необходимо открыть</div><div class="line">         после запуска остальных объектов */</div><div class="line">      &quot;startup_priority&quot;: 0,</div><div class="line">      /* Приоритет остановки. Укажите максимальный (минимальное значение), если порты необходимо закрыть </div><div class="line">         в первую очередь */</div><div class="line">      &quot;shutdown_priority&quot;: 0,</div><div class="line"></div><div class="line">      /* Номера ядер CPU для потоков сервера, например [1,2,3] */</div><div class="line">      &quot;cpu&quot;: [],</div><div class="line"></div><div class="line">      /* Цель - куда передать полученные данные */</div><div class="line">      &quot;target&quot;: &quot;&quot;,</div><div class="line"></div><div class="line">      /* По умолчанию использовать разделитель `\r\n` для сообщений. </div><div class="line">         Если false, то настраивается в connection */</div><div class="line">      &quot;rn&quot;: true,</div><div class="line"></div><div class="line">      /* Не закрывать соединение после отправки ответа */</div><div class="line">      &quot;keep_alive&quot;: true,</div><div class="line"></div><div class="line">      /* Число потоков. 0-в основном потоке приложения, 1-в отдельном потоке, N-акцептор на поток*/</div><div class="line">      &quot;threads&quot;: 0,</div><div class="line"></div><div class="line">      /* Адрес */</div><div class="line">      &quot;addr&quot;: &quot;&quot;,</div><div class="line">      /* Порт */</div><div class="line">      &quot;port&quot;: &quot;&quot;,</div><div class="line">      /* Системная очередь новых соединений */</div><div class="line">      &quot;backlog&quot;: 1024,</div><div class="line">      /* Максимальное количество одновременных подключения. 0 - без ограничения */</div><div class="line">      &quot;max_connections&quot;: 0,</div><div class="line"></div><div class="line">      /* Настройки соединения */</div><div class="line">      &quot;connection&quot;: {</div><div class="line">        /* В режиме direct_mode=true отключается регистрация нового соединения в целевом объекте.</div><div class="line">           Работает быстрее, но не все целевые объекты поддерживают такой режим, например очередь </div><div class="line">           c tracking=true () */</div><div class="line">        &quot;direct_mode&quot;: false,</div><div class="line"></div><div class="line">        /* Размер буфера приема сообщений сокета (SOL_SOCKET/SO_RCVBUF). 0 - не изменять */</div><div class="line">        &quot;receive_buffer_size&quot;: 0,</div><div class="line"></div><div class="line">        /* Размер буфера отправки сокета (SOL_SOCKET/SO_SNDBUF). 0 - не изменять */ */</div><div class="line">        &quot;send_buffer_size&quot;: 0,</div><div class="line"></div><div class="line">        &quot;reader&quot;: {</div><div class="line">          /* Разделитель входящих сообщений. Если задан, то поле rn-игнорируется и используется</div><div class="line">             это значение. Если не задан (=&quot;&quot;) и если rn=true, то это эквивалентно sep=&quot;\r\n&quot;.</div><div class="line">             Если не задан (=&quot;&quot;) и если rn=false, то без разделения, для двоичных данных. */</div><div class="line">          &quot;sep&quot;: &quot;&quot;,</div><div class="line">          /* Рекомендуемый размер приемного буфера (в бинарном режиме фиксированный)*/</div><div class="line">          &quot;bufsize&quot;: 4096,</div><div class="line">          /* Максимальный рекомендуемый размер приемного буфера */</div><div class="line">          &quot;maxbuf&quot;: 8192,</div><div class="line">          /* Минимальный рекомендуемый размер приемного буфера */</div><div class="line">          &quot;minbuf&quot;: 0,</div><div class="line">          /* Максимальный размер входящего сообщения если указан разделитель. 0-без ограничений.*/</div><div class="line">          &quot;maxsize&quot;: 0,</div><div class="line">          /* Удалять разделитель из */</div><div class="line">          &quot;trimsep&quot;: true</div><div class="line">        },</div><div class="line"></div><div class="line">        &quot;writer&quot;: {</div><div class="line">          /* Разделитель исходящих сообщений. Просто добавляет его в конец сообщения.</div><div class="line">             Если задан, то поле rn-игнорируется и используется это значение.</div><div class="line">             Если не задан (=&quot;&quot;) и если rn=true, то это эквивалентно sep=&quot;\r\n&quot;.</div><div class="line">          */</div><div class="line">          &quot;sep&quot;: &quot;&quot;,</div><div class="line">          /* Размер исходящего буфера. Если сообщение превышает maxbuf, то оно разбивается на </div><div class="line">             несколько буферов размеров bufsize, для оптимизации отправки */</div><div class="line">          &quot;bufsize&quot;: 8192,</div><div class="line">          /* Максимальный размер буфера, до его разбиения */</div><div class="line">          &quot;maxbuf&quot;: 8192,</div><div class="line">          /* Минимальный размер буфера. Если текущий меньше этого значения, то он объединится </div><div class="line">             со следующим*/</div><div class="line">          &quot;minbuf&quot;: 0,</div><div class="line">          /* Максимальный размер исходящего сообщения. Если 0, то предполагается равным maxbuf */</div><div class="line">          &quot;maxsize&quot;: 0,</div><div class="line">          /* Попытка отправить сообщение превышающее _maxbuf с первой попытки, а только потом </div><div class="line">             разбить оставшиеся. Если возможна отправка сообщений более 1МБ, то рекомендуется </div><div class="line">             установить first_as_is=false, чтобы гарантировано разбить большое сообщения, для максимально </div><div class="line">             эффективной записи в сокет */</div><div class="line">          &quot;first_as_is&quot;: true</div><div class="line">        }</div><div class="line">      }</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p> Значения по умолчанию для размеров буферов <b>reader</b> и <b>writer</b> подобраны оптимально, для любых размеров сообщений. Но вы можете уменьшить их, если основной поток из сообщений небольшого размера. Увеличивать размеры больше 64К не имеет смысла для любых размеров сообщений.</p>
<p class="">Когда клиент подключается к серверу, то тот создает новый объект подключения, о чем уведомляется целевой объект (target). После отключения клиента, объект уничтожается, о чем так же происходит уведомление. Эти уведомления можно отключить установив direct_mode=true, если целевые объекты их не обрабатывают или могут работать без них. Например очереди по этим уведомлениям выкидывают сообщения для клиентов, которые закрыли подключение. Если включить direct_mode=true, то такой возможности уже не будет, и сообщение будет обработано, даже если получатель ответа уже отключился. Однако, если отключений клиентов не происходит (как правило по таймауту), то можно немного снизить нагрузку на CPU включив direct_mode.</p>
<p class="">Для jsonrpc конфигурация включает как минимум три компонента:</p><ul>
<li>server-tcp или server-udp</li>
<li>jsonrpc-сервис - компонент предоставляемый разработчиком, например hash-service. Он преобразует jsonrpc-сообщения в вызовы API прикладного объекта</li>
<li>Прикладной объект, где реализована вся логика, например hash.</li>
</ul>
<div class="fragment"><div class="line">┌─────────────┐  ┌───────────────┐  ┌───────┐</div><div class="line">│ server-tcp  ├──┤ hash-service  ├──┤ hash  │</div><div class="line">└─────────────┘  └───────────────┘  └───────┘</div></div><!-- fragment --> <div class="fragment"><div class="line">{</div><div class="line">  &quot;server-tcp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-tcp1&quot;,</div><div class="line">      &quot;threads&quot;: 1,</div><div class="line">      &quot;target&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">      &quot;port&quot;: &quot;12346&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash-service&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash1&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash1&quot;</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><h2>server-udp</h2>
<p class="">Для UDP сервера настроек меньше, но оставшиеся совпадают по описанию с TCP, но нужно иметь ввиду, что это датаграмный протокол, и разбиение на сообщения происходит только внутри одной датаграмы. </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;server-udp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-udp1&quot;,</div><div class="line">      &quot;enabled&quot;: true,</div><div class="line">      &quot;suspend&quot;: false,</div><div class="line">      &quot;startup_priority&quot;: 0,</div><div class="line">      &quot;shutdown_priority&quot;: 0,</div><div class="line">      &quot;cpu&quot;: [],</div><div class="line">      &quot;target&quot;: &quot;&quot;,</div><div class="line">      &quot;rn&quot;: true,</div><div class="line">      &quot;threads&quot;: 0,</div><div class="line">      &quot;addr&quot;: &quot;&quot;,</div><div class="line">      &quot;port&quot;: &quot;&quot;,</div><div class="line">      &quot;receive_buffer_size&quot;: 0,</div><div class="line">      &quot;send_buffer_size&quot;: 0,</div><div class="line">      &quot;reader&quot;: {</div><div class="line">        &quot;sep&quot;: &quot;&quot;,</div><div class="line">        &quot;bufsize&quot;: 4096,</div><div class="line">        &quot;maxbuf&quot;: 8192,</div><div class="line">        &quot;minbuf&quot;: 0,</div><div class="line">        &quot;maxsize&quot;: 0,</div><div class="line">        &quot;trimsep&quot;: true</div><div class="line">      },</div><div class="line">      &quot;writer&quot;: {</div><div class="line">        &quot;sep&quot;: &quot;&quot;,</div><div class="line">        &quot;bufsize&quot;: 8192,</div><div class="line">        &quot;maxbuf&quot;: 8192,</div><div class="line">        &quot;minbuf&quot;: 0,</div><div class="line">        &quot;maxsize&quot;: 0,</div><div class="line">        &quot;first_as_is&quot;: true</div><div class="line">      }</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p class="">Важно! Значения по умолчанию для reader/writer для датаграм 4КБ, возможно вам будет необходимо увеличить <b>bufsize</b> до максимального возможного размера датаграм 64КБ. При высоких нагрузках рекомендуется также задать <b>receive_buffer_size</b>, например:</p>
<div class="fragment"><div class="line">&quot;server-udp&quot;: [</div><div class="line">  {</div><div class="line">    &quot;name&quot;: &quot;server-udp1&quot;,</div><div class="line">    &quot;startup_priority&quot;:  1000,</div><div class="line">    &quot;shutdown_priority&quot;: -1000,</div><div class="line">    &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">    &quot;port&quot;: &quot;38000&quot;,</div><div class="line">    &quot;target&quot;: &quot;service1&quot;,</div><div class="line">    &quot;reader&quot;: { &quot;bufsize&quot;: 65535},</div><div class="line">    &quot;writer&quot;: { &quot;bufsize&quot;: 65535},</div><div class="line">    &quot;receive_buffer_size&quot;: 128000000,</div><div class="line">    &quot;threads&quot;: 16</div><div class="line">  }</div><div class="line">]</div></div><!-- fragment --><p> Обычно UDP-порт открывают одновременно с TCP, например:</p>
<div class="fragment"><div class="line">┌─────────────┐                           </div><div class="line">│ server-tcp  ├─┐                         </div><div class="line">└─────────────┘ │   ┌───────────────┐   ┌───────┐</div><div class="line">                ├───┤ hash-service  ├───┤ hash  │</div><div class="line">┌─────────────┐ │   └───────────────┘   └───────┘</div><div class="line">│ server-udp  ├─┘</div><div class="line">└─────────────┘</div></div><!-- fragment --><div class="fragment"><div class="line">{</div><div class="line">  &quot;server-tcp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-tcp1&quot;,</div><div class="line">      &quot;threads&quot;: 1,</div><div class="line">      &quot;target&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">      &quot;port&quot;: &quot;12346&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;server-udp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-udp1&quot;,</div><div class="line">      &quot;threads&quot;: 1,</div><div class="line">      &quot;target&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">      &quot;port&quot;: &quot;12346&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash-service&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash1&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash1&quot;</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><h2>io-queue</h2>
<p class="">Все настройки связанные с управлением очередями осуществляются в компоненте <a href="https://github.com/mambaru/wfc_core">workflow</a>, имя которого необходимо указать в поле **"workflow"**. Таким образом несколько очередей могут обрабатываться одним пулом потоков. Обратную очередь имеет смысл включать если ответные сообщения могут иметь большой размер. Поле <b>tracking</b> позволяет включить режим отслеживания отключения клиента, </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;io-queue&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;io-queue1&quot;,</div><div class="line">      &quot;enabled&quot;: true,</div><div class="line">      &quot;suspend&quot;: false,</div><div class="line">      &quot;tracking&quot;: false,</div><div class="line">      &quot;workflow&quot;: &quot;&quot;,</div><div class="line">      &quot;target&quot;: &quot;&quot;,</div><div class="line">      &quot;callback_queue&quot;: false,</div><div class="line">      &quot;callback_workflow&quot;: &quot;&quot;</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p> Если у вас система настроена на работу с jsonrpc, то использовать этот компонент не оптимально, jsonrpc-queue больше для этого подходит. Пример для общей очереди: </p><div class="fragment"><div class="line">┌─────────────┐</div><div class="line">│ server-tcp  ├─┐</div><div class="line">└─────────────┘ │     ┌──────────┐    ┌───────────────┐   ┌───────┐</div><div class="line">                ├─────┤ io-queue ├────┤ hash-service  ├───┤ hash  │</div><div class="line">┌─────────────┐ │     └──────────┘    └───────────────┘   └───────┘</div><div class="line">│ server-udp  ├─┘   common workflow</div><div class="line">└─────────────┘</div></div><!-- fragment --><div class="fragment"><div class="line">{</div><div class="line">  &quot;server-tcp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-tcp1&quot;,</div><div class="line">      &quot;target&quot;: &quot;queue1&quot;,</div><div class="line">      &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">      &quot;port&quot;: &quot;12346&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;server-udp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-udp1&quot;,</div><div class="line">      &quot;target&quot;: &quot;queue1&quot;,</div><div class="line">      &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">      &quot;port&quot;: &quot;12346&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;io-queue&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;queue1&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash-service1&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash-service&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash1&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash1&quot;</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p> Еще пример: </p><div class="fragment"><div class="line">                  workflow1</div><div class="line">┌─────────────┐  ┌──────────┐</div><div class="line">│ server-tcp  ├──┤ io-queue ├─┐</div><div class="line">└─────────────┘  └──────────┘ │  ┌───────────────┐   ┌───────┐</div><div class="line">                              ├──┤ hash-service  ├───┤ hash  │</div><div class="line">┌─────────────┐  ┌──────────┐ │  └───────────────┘   └───────┘</div><div class="line">│ server-udp  ├──┤ io-queue ├─┘</div><div class="line">└─────────────┘  └──────────┘</div><div class="line">                  workflow2</div></div><!-- fragment --> <div class="fragment"><div class="line">{</div><div class="line">  &quot;server-tcp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-tcp1&quot;,</div><div class="line">      &quot;target&quot;: &quot;queue1&quot;,</div><div class="line">      &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">      &quot;port&quot;: &quot;12346&quot;,</div><div class="line">      &quot;threads&quot;: 1</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;server-udp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-udp1&quot;,</div><div class="line">      &quot;target&quot;: &quot;queue2&quot;,</div><div class="line">      &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">      &quot;port&quot;: &quot;12346&quot;,</div><div class="line">      &quot;threads&quot;: 1</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;io-queue&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;queue1&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;tracking&quot;: true,</div><div class="line">      &quot;workflow&quot;:&quot;workflow1&quot;</div><div class="line">    },</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;queue2&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;workflow&quot;:&quot;workflow1&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash-service&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash1&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash1&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line"></div><div class="line">  &quot;workflow&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;workflow1&quot;,</div><div class="line">      &quot;threads&quot;: 1,</div><div class="line">      &quot;maxsize&quot;: 10</div><div class="line">    },</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;workflow2&quot;,</div><div class="line">      &quot;threads&quot;: 5</div><div class="line">    },</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><h2>io-broker</h2>
<p class="">Позволяет управлять входным потоком с помощью регулярных выражений. Для jsonrpc лучше подойдет jsonrpc-broker </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;io-broker&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;io-broker1&quot;,</div><div class="line">      &quot;enabled&quot;: true,</div><div class="line">      /* В режиме suspend отправляет поток в **target**  */</div><div class="line">      &quot;suspend&quot;: false,</div><div class="line">      /* Цель по умолчанию (если пустая, то сообщение выкидывается из очереди ) */</div><div class="line">      &quot;target&quot;: &quot;&quot;,</div><div class="line">      /* Имя лога (не путь), если хотите чтобы сообщение писалось еще и туда */</div><div class="line">      &quot;target_log&quot;: &quot;&quot;,</div><div class="line">      &quot;rules&quot;: [</div><div class="line">        {</div><div class="line">          /* Цель для правила */</div><div class="line">          &quot;target&quot;: &quot;&quot;,</div><div class="line">          /* Имя лога (не путь), если хотите чтобы сообщение писалось еще и туда, для этой цели */</div><div class="line">          &quot;rule_log&quot;: &quot;&quot;,</div><div class="line">          /* Регулярное выражение */</div><div class="line">          &quot;regex&quot;: &quot;&quot;</div><div class="line">        }</div><div class="line">      ]</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p class="">Пример: </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;io-broker&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;io-broker1&quot;,</div><div class="line">      &quot;rules&quot;: [</div><div class="line">        {</div><div class="line">          &quot;target&quot;: &quot;target1&quot;,</div><div class="line">          &quot;rule_log&quot;: &quot;rule1&quot;,</div><div class="line">          &quot;regex&quot;: &quot;.*&quot;</div><div class="line">        }</div><div class="line">      ]</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p class="">Пример когда jsonrpc-запросы и остальные распределяются по разным очередям. </p><div class="fragment"><div class="line">                                workflow1</div><div class="line">┌─────────────┐                ┌──────────┐non jsonrpc</div><div class="line">│ server-tcp  ├─┐            ┌─┤ io-queue ├─┐</div><div class="line">└─────────────┘ │ ┌────────┐ │ └──────────┘ │  ┌──────────────┐   ┌──────┐</div><div class="line">                ├─┤ broker ├─┤              ├──┤ hash-service ├───┤ hash │</div><div class="line">┌─────────────┐ │ └────────┘ │ ┌──────────┐ │  └──────────────┘   └──────┘</div><div class="line">│ server-udp  ├─┘            └─┤ io-queue ├─┘</div><div class="line">└─────────────┘                └──────────┘jsonrpc</div><div class="line">                                workflow2</div></div><!-- fragment --> <div class="fragment"><div class="line">{</div><div class="line">  &quot;server-tcp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-tcp1&quot;,</div><div class="line">      &quot;target&quot;: &quot;broker1&quot;,</div><div class="line">      &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">      &quot;port&quot;: &quot;12346&quot;,</div><div class="line">      &quot;threads&quot;: 1</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;server-udp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;server-udp1&quot;,</div><div class="line">      &quot;target&quot;: &quot;broker1&quot;,</div><div class="line">      &quot;addr&quot;: &quot;0.0.0.0&quot;,</div><div class="line">      &quot;port&quot;: &quot;12346&quot;,</div><div class="line">      &quot;threads&quot;: 1</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;io-broker&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;broker1&quot;,</div><div class="line">      &quot;target&quot;:&quot;queue1&quot;,</div><div class="line">      &quot;log&quot;:&quot;BRLOG1&quot;,</div><div class="line">      &quot;rules&quot;: [</div><div class="line">        {</div><div class="line">          &quot;target&quot;:&quot;queue2&quot;,</div><div class="line">          &quot;regex&quot;:&quot;{.*}$&quot;,</div><div class="line">          &quot;log&quot;:&quot;BRLOG2&quot;</div><div class="line">        }</div><div class="line">      ]</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;io-queue&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;queue1&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;tracking&quot;: true,</div><div class="line">      &quot;workflow&quot;:&quot;workflow1&quot;</div><div class="line">    },</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;queue2&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;workflow&quot;:&quot;workflow2&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash-service&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash-service1&quot;,</div><div class="line">      &quot;target&quot;: &quot;hash1&quot;,</div><div class="line">      &quot;allow_non_jsonrpc&quot;:true</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;hash&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;hash1&quot;</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;workflow&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;workflow1&quot;,</div><div class="line">      &quot;threads&quot;: 1,</div><div class="line">      &quot;maxsize&quot;: 10</div><div class="line">    },</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;workflow2&quot;,</div><div class="line">      &quot;threads&quot;: 5</div><div class="line">    },</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><h2>client-tcp1</h2>
<p class="">Устанавливает постоянное подключение с другим сервером для каждого потребителя (прикладной объект).</p>
<div class="fragment"><div class="line">{</div><div class="line">  &quot;client-tcp&quot;: [</div><div class="line">    {</div><div class="line">      &quot;name&quot;: &quot;client-tcp1&quot;,</div><div class="line">      &quot;enabled&quot;: true,</div><div class="line">      &quot;suspend&quot;: false,</div><div class="line">      &quot;startup_priority&quot;: 0,</div><div class="line">      &quot;shutdown_priority&quot;: 0,</div><div class="line">      /* Workflow для таймеров повторного подключения */</div><div class="line">      &quot;workflow&quot;: &quot;&quot;,</div><div class="line">      &quot;rn&quot;: true,</div><div class="line">      /* Завершить приложения при ошибках сети */</div><div class="line">      &quot;abort_if_error&quot;: true,</div><div class="line">      /* Пул клиентов при старте приложения */</div><div class="line">      &quot;startup_pool&quot;: 1,</div><div class="line">      /* Постоянный пул клиентов */</div><div class="line">      &quot;primary_pool&quot;: 0,</div><div class="line">      /* Вторичный пул клиентов */</div><div class="line">      &quot;secondary_pool&quot;: 0,</div><div class="line">      &quot;addr&quot;: &quot;&quot;,</div><div class="line">      &quot;port&quot;: &quot;&quot;,</div><div class="line">      /* Количество подключений на клиент */</div><div class="line">      &quot;connect_count&quot;: 1,</div><div class="line">      /* Потоков на клиент */</div><div class="line">      &quot;threads&quot;: 0,</div><div class="line">      /* Асинхронное подключение */</div><div class="line">      &quot;async_connect&quot;: false,</div><div class="line">      /* Тамаут повторного подключения в миллисекундах */</div><div class="line">      &quot;reconnect_timeout_ms&quot;: 1000,</div><div class="line"></div><div class="line">      /* Настройки аналогично TCP серверу */</div><div class="line">      &quot;connection&quot;: {</div><div class="line">        &quot;receive_buffer_size&quot;: 0,</div><div class="line">        &quot;send_buffer_size&quot;: 0,</div><div class="line">        &quot;reader&quot;: {</div><div class="line">          &quot;sep&quot;: &quot;&quot;,</div><div class="line">          &quot;bufsize&quot;: 4096,</div><div class="line">          &quot;maxbuf&quot;: 8192,</div><div class="line">          &quot;minbuf&quot;: 0,</div><div class="line">          &quot;maxsize&quot;: 0,</div><div class="line">          &quot;trimsep&quot;: true</div><div class="line">        },</div><div class="line">        &quot;writer&quot;: {</div><div class="line">          &quot;sep&quot;: &quot;&quot;,</div><div class="line">          &quot;bufsize&quot;: 8192,</div><div class="line">          &quot;maxbuf&quot;: 8192,</div><div class="line">          &quot;minbuf&quot;: 0,</div><div class="line">          &quot;maxsize&quot;: 0,</div><div class="line">          &quot;first_as_is&quot;: true</div><div class="line">        }</div><div class="line">      }</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p> Стандартная схема, на примере <a href="https://github.com/mambaru/wfc_demo">workflow</a> где прикладной объект demo удаленно, по jsonrpc, обращается к объекту hash:</p>
<div class="fragment"><div class="line">┌───────────┐  ┌──────────────┐</div><div class="line">│server-tcp ├──┤ demo-service ├┐</div><div class="line">└───────────┘  └──────────────┘│</div><div class="line"> ┌─────────────────────────────┘</div><div class="line"> │┌───────┐  ┌──────────────┐  ┌─────────────┐    |    ┌─────────────┐  ┌──────────────┐  ┌───────┐</div><div class="line"> └┤ demo  ├──┤ hash-gateway ├──┤ client-tcp  ├ - -|- -&gt;┤ server-tcp  ├──┤ hash-service ├──┤ hash  │</div><div class="line">  └───────┘  └──────────────┘  └─────────────┘    |    └─────────────┘  └──────────────┘  └───────┘</div></div><!-- fragment --><p class="">Для такой схемы, настроек пула подключений (<em>startup_pool</em>, <em>primary_pool</em>, <em>secondary_pool</em>) по умолчанию вполне достаточно, так как к клиенту подключается один экземпляр объекта. Клиент может сделать несколько постоянных подключений (<em>connect_count</em>=N*) и отправлять исходящие сообщения по очереди по каждому из них (эффективность такого решения сильно зависит от архитектуры удаленного сервера)</p>
<p class="">Если объектов использующих client-tcp счетное количество, то достаточно указать это число <em>startup_pool</em>=X, тогда при старте будет создано X экземпляров клиентов, с <em>connect_count</em>=N* подключений и <em>threads</em> * X потоков обработки. (на каждый экземпляр создается свой пул потоков)</p>
<p class="">Но также появилась возможность подключать server-tcp напрямую к клиенту или через io-объкты (io-queue, io-broker). В этом случае для каждого подключения сервера создается свой клиент. Для того, чтобы не блокировать сервер блокируемым подключением, сделаете его неблокируемым (<em>async_connect</em>=true), и настройте пул клиентов:</p><ul>
<li><b>startup_pool</b> - пул который будет заполнен при старте, и из него будут извлекаться подключенные объекты, до тех пор пока он не опустеет. Далее не используется.</li>
<li><b>primary_pool</b> - пул постоянно поддерживает заданное количество подключенных объектов, при извлечении автоматически в фоне создает новое. Из этого пула извлекаются объекты в последнюю очередь.</li>
<li><b>secondary_pool</b> - изначально пустой пул в который возвращаются отработанные объекты. Сначала извлекаются объекты из <b>startup_pool</b>, потом отсюда и только потом <b>primary_pool</b>. Отработанные клиенты из <b>primary_pool</b> также помещаются сюда </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
